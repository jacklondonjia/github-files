<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!--  $Id: release_history.html 123 2011-11-01 13:01:33Z peterod $-->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemalocation="http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd" xml:lang="en">
<head>
    <title>IAR Embedded Workbench Release History</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <link type="text/css" rel="stylesheet" media="all" href="style/ewic.css" />
</head>
<body>
    <div id="topbanner">
    </div>
    <div id="titlebanner_small">
        <h2>Release History</h2>
    </div>
    <div class="breadcrumb">
        <a href="index.JPN.html">ARM用IARインフォメーションセンタ </a> | <a href="release_notes.JPN.html">リリースノート</a> | <a href="components.JPN.html">コンポーネント</a> | <a href="iccarm.JPN.html">ARM用 IAR C/C++ コンパイラのリリースノート</a> | リリースノート
    </div>    
    <div class="mainblock">
    <h2>
        Release History
    </h2>
﻿<!-- $Id: release_history.JPN.html 48615 2011-11-08 09:08:18Z danielru $ -->
    <ul>
      <li>
<A HREF="#his621">V6.21</A> 2011-07-05 
      </li>   
      <li>
<A HREF="#his620">V6.20</A> 2011-04-29 
      </li>   
      <li>
<A HREF="#his610">V6.10</A> 2010-11-04 
      </li>   
      <li>
<A HREF="#his550">V5.50</A> 2010-04-21   
      </li>   
      <li>
<A HREF="#his541">V5.41</A> 2009-12-14   
      </li>   
      <li>
<A HREF="#his540">V5.40</A> 2009-07-10   
      </li>   
      <li>
<A HREF="#his530">V5.30</A> 2009-01-23   
      </li>   
      <li>
<A HREF="#his520">V5.20</A> 2008-06-24   
      </li>   
      <li>
<A HREF="#his511">V5.11</A> 2007-12-11   
      </li>   
      <li>
<A HREF="#his510">V5.10</A> 2007-06-12   
      </li>   
    </ul>
    <p></p>

    <!-- ============================================== -->

<h4><A NAME="his621">V6.21 2011-07-05</A></h4>
<b>新機能</b>
<ul>
<li>なし。</li>
</ul>

<b>プログラム修正</b>	
<ul>
<li>
  <p>
アドレス情報(<code>#pragma location</code>または<code>@</code>演算子から)が、関数の宣言から関数定義へと正しく引き継がれるようになりました。<br>例：<br><code>int foo(void) @ &quot;XXX&quot;;<br> int foo(void) { return 1; }<br></code> 関数<code>foo()</code>はセクション<code>XXX</code>に配置されるべきですが、そうなっていませんでした。<br>[EW22448]
  </p>
</li>

<li>
  <p>
一致しないアドレス文字列で<code>main</code>を再度宣言して結果のエラーを無効化すると、コンパイラでインターナルエラーが発生していました。この場合、エラーを無効化できなくなりました。<br>[EW22450]
  </p>
</li>

<li>
  <p>
複数の定数を持つ可換の演算が、1つまたは複数の演算がより小さい型の場合であっても、間違って最適化されなくなりました。<br>[EW22470、EW22484]
  </p>
</li>

<li>
  <p>
ネストされた割込みハンドラについて、<code>LR</code>が調整されました。<br>[EW22472]
  </p>
</li>

<li>
  <p>
インラインテンプレート関数内の文字列リテラルが、constでない変数に変換されていました。これらの変数は<code>const</code>となり、仕様のとおりにROM内に配置されます。<br>[EW22475]
  </p>
</li>

<li>
  <p>
インターナルエラーを修正しました。<br>[EW22479]
  </p>
</li>

<li>
  <p>
EWARM 6.21.4:<br>特定の小さい切替え文で、コンパイラが呼び出しごとに異なるコードを生成していました。これは修正されました。<br>[EW22520]
  </p>
</li>

<li>
  <p>
EWARM 6.21.4:<br>自動オブジェクト内の構造体メンバに対するストアが、オブジェクトのメンバがオブジェクトのアドレスが関数に引き渡される前に一度読み込まれる場合に、誤って最適化されていました。<br>[EW22537]
  </p>
</li>

<li>
  <p>
EWARM 6.21.4:<br>コンパイラが、部分的な定義の範囲拡張を回避するようになりました。<br>[EW22539]
  </p>
</li>

<li>
  <p>
EWARM 6.21.4:<br>Thumb-1命令<code>ADD.N Rdn,Rdn,SP</code>の範囲が拡張されるとき、<code>ADD.W Rdn,Rdn,SP</code>は予測不可能なため、同等のThumb-2命令<code>ADD.W Rdn,SP,Rdn</code>が使用されます。<br>[EW22555]
  </p>
</li>

<li>
  <p>
EWARM 6.21.4:<br>コンパイラが、分岐とターゲット間に非常に多くの定数や文字列リテラルを配置しなくなりました。<code>LR</code>がプッシュされないThumb-1関数によって、&quot;Internal error: Jump distance to far for B&quot;が発生することがありました。<br>[EW22611]
  </p>
</li>

<li>
  <p>
EWARM 6.21.4:<br><code>ASR</code>、<code>LSR</code>、<code>LSL</code>、<code>ROR</code>、<code>RRX</code>への参照をコンパイルするときに、コンパイラがクラッシュしなくなりました。<br>[EW22614]
  </p>
</li>
</ul>

<h4><A NAME="his620">V6.20 2011-04-29</A></h4>
<b>新機能</b>
  <ul>
       <li><p>
<code>time.h</code>に-9999から9999までの年号をサポートするオプションの64ビットインタフェースが付属になりました。詳しくは、<A href="../EWARM_DevelopmentGuide.JPN.pdf">開発ガイド</A>を参照してください。
       </p></li>

  </ul>
<b>プログラム修正</b>	
  <ul>
 
<li>
  <p>
<code>--use_c++_inline</code>オプションを使用してCファイルをコンパイルするときに、publicインライン関数の定義がインターナルリンケージを持つ関数や変数を参照できないというC99の規則がチェックされなくなりました。<br>[EW22161]
  </p>
</li>

<li>
  <p>
ループ本体の最後の文がswitchであるループによって、最適化レベルが「高」のときにインターナルエラーがトリガされなくなりました。<br>[EW22183]
  </p>
</li>

<li>
  <p>
C++ Cシステムヘッダ(<code>errno.h</code>など)が、<code>extern &quot;C&quot;</code>ブロック内にインクルード可能になりました。<br>[EW22188]
  </p>
</li>

<li>
  <p>
ループ本体に複数のリターンを持つ<code>while</code>ループによって、インターナルエラーがトリガされなくなりました。<br>[EW22195]
  </p>
</li>

<li>
  <p>
コンパイラで、マルチバイトを含むマクロパラメータを処理できるようになりました。<br>[EW22214]
  </p>
</li>

<li>
  <p>
非常に多くの定数データシンボルを持つモジュールのコンパイルが、かなり高速になりました。<br>[EW22243]
  </p>
</li>

<li>
  <p>
マクロ引数内でユーザ定義マクロに<code>offsetof</code>マクロが使用される場合、コンパイラが<code>offsetof</code>マクロの内容に関して不要なワーニングを出力しなくなりました。<br>[EW22250]
  </p>
</li>

<li>
  <p>
製品に付属のファイル<code>arm\src\lib\thumb\cstartup_M.c</code>とリンクするときに、シンボル<code>__vector_table</code>がインクルードされるようになりました。<br>[EW22252]
  </p>
</li>

<li>
  <p>
コンパイラで、コメント内およびソース行の接合メカニズムでマルチバイト文字が正しく処理されるようになりました。<br>[EW22276]
  </p>
</li>

<li>
  <p>
2番目のテストを使用して1回だけループの繰り返しを実行すると判断するときに、複数のテストと空白のループ本体を持つ1回きりのループが展開できるようになりました。<br>[EW22295]
  </p>
</li>

<li>
  <p>
左シフトおよび減算の関係する複雑な式が、常に正しく最適化されるようになりました。<br>[EW22306]
  </p>
</li>

<li>
  <p>
場合によっては、コンパイラがマイナス8ビットのイミディエイトを持つThumb-2 <code>ADD</code>命令を生成することがあり、これがアセンブラによってnarrowThumb-1 <code>SUB</code>命令に変換されていました。これは修正されました。<br>[EW22308]
  </p>
</li>

<li>
  <p>
MISRA-C規則が、<code>#pragma location</code>内や<code>@</code>演算子の後のアドレスに誤って定数式に適用され、MISRA-Cチェックが有効な場合に間違った診断が行われていました。これは修正されました。<br>[EW22321]
  </p>
</li>

<li>
  <p>
アドレスのオペランドが<code>[&lt;Rn&gt;,&lt;Rm&gt;,#&lt;imm&gt;]</code>の形式のときに、Thumb-2のコードを生成して64ビットのストアを32ビットのストアに分割しようとしても(アラインメントのためなど)、インターナルエラーが出力されなくなりました。<br>[EW22324]
  </p>
</li>

<li>
  <p>
メンバへのポインタへの関数の非標準の暗黙的キャストに対して、コンパイラでエラーが出力されるようになりました。<br>[EW22337]
  </p>
</li>

<li>
  <p>
トランポリン関数<code>__iar_via_rw_&lt;Rn&gt;</code>が書込み可能なセクションフラグメントとして生成されるようになり、こうした関数が必要なケースでも<code>__ramcode</code>関数が使用可能になりました。<br>[EW22346]
  </p>
</li>

<li>
  <p>
EWARM 6.20.2:<br>条件付きのジャンプを最適化するときに、コンパイラがインターナルエラーで終了しなくなりました。<br>[EW22404]
  </p>
</li>

<li>
  <p>
EWARM 6.20.2:<br>メディア拡張を持つコアの場合、コンパイラで<code>{S,U}XTA{B,H}</code>ではなく<code>ADD</code>が生成されなくなりました。<br>[EW22407]
  </p>
</li>

<li>
  <p>
EWARM 6.20.2:<br>アドレスのオペランドが<code>[&lt;Rn&gt;,&lt;Rm&gt;,#&lt;imm&gt;]</code>の形式のときに、Thumb-2のコードを生成して64ビットのロードを32ビットのロードに分割しようとしても(アラインメントのためなど)、インターナルエラーが出力されなくなりました。<br>[EW22415]
  </p>
</li>

<li>
  <p>
EWARM 6.20.2:<br>構造体または構造体配列の静的初期化において、名前のないビットフィールドに続くフィールドで間違った値が取得されなくなりました。<br>[EW22416]
  </p>
</li>

<li>
  <p>
EWARM 6.20.2:<br>構造体またはクラス定義に対してキーワード<code>__packed</code>を使用する際に、コンパイラが間違ってワーニングPe021(この場合、型修飾子は無効)を出力していました。<br>[EW22417]
  </p>
</li>

<li>
  <p>
EWARM 6.20.2:<br><code>goto</code>文を持つループで、すべてのケースについてインターナルエラーがトリガされなくなりました。<br>[EW22420]
  </p>
</li>

<li>
  <p>
EWARM 6.20.2:<br>定数の整数だけからなる集合イニシャライザで、イニシャライザで指定されていない部分にある2つより下位レベルにネストされた非整数と非集合型が関係する場合、コンパイラがインターナルエラーにより終了しなくなりました。<br>[EW22424]
  </p>
</li>

<li>
  <p>
EWARM 6.20.3:<br>Thumb-2コードを生成する際、大きなスタックフレーム上で32ビットの浮動小数点値にアクセスしてもインターナルエラーが発生しなくなりました。<br>[EW22439]
  </p>
</li>

<li>
  <p>
EWARM 6.20.3:<br>整数からのキャストを含むポインタ定数が、間違った型を取得することがあり、不正なエラーやインターナルエラーの原因となっていました。これは修正されました。<br>[EW22441]
  </p>
</li>
  </ul>


<h4><A NAME="his610">V6.10 2010-11-04</A></h4>
<b>新機能</b>
  <ul>
<li><p> 本製品は1999年に定義された最新のC規格(C99)をデフォルトのC言語として使用しています。本製品の以前のメジャーバージョンでは、1989年に定義された古いC規格(C89)を使用していました。<code>--c89</code>オプションを使用すると、コンパイラでC89をまだ使用することができます。一部のC99の機能のサポートが中止されているため、この製品は旧バージョンと完全に互換性があるわけではありません。C99の可変長配列、VLAは、デフォルトのC言語ではサポートされていません。オプション<code>--vla</code>を使用すると、これらを有効にできます。CライブラリはすべてのC99機能をサポートしていますが、C99言語か任意のC++言語と併用している場合に限ります。C89言語と併用する場合、C99で追加された機能は使用できません。</p></li>
<li><p> EC++およびEEC++の実装は、大きくは変わってはいません。</p></li>
<li><p> C++言語のサポートが追加されました。デフォルトでは、2003 C++規格が完全にサポートされていますが、<code>--no_exceptions</code>および<code>--no_rtti</code>を使用することにより、例外とランタイム型情報をそれぞれ無効にした状態で使用できます。</p></li>
<li><p>スレッドセーフライブラリ<br /> DLIBライブラリは、スレッド環境での使用をサポートするようになりました。ヒープやファイル構造と同じように、一部のライブラリシステムはロックにより保護されます。<code>locale</code>や<code>errno</code>のような他のライブラリシステムは、静的データがスレッドのローカル記憶に割り当てられます。DLIBスレッドのサポートはユーザが選択したRTOSでサポートされるか、または手動で実装できます。詳しくは、<A href="../EWARM_DevelopmentGuide.JPN.pdf">開発ガイド</A>を参照してください。
          </p></li>
<li><p> コンパイラとアセンブラは、ライブラリのシステムヘッダファイルがある場所を自動的に認識できるようになりました。以下のオプションを使用してコンパイラを制御できます。 
               <ul>
<li><code>--dlib_config</code>を使用して、DLIBライブラリの構成を選択します。</li>
<li><code>--system_include_dir</code>を使用すると、システムヘッダのベースとして使用するディレクトリをオーバライドできます。</li>
<li><code>--no_system_include</code>を使用して、自動化をオフにすることができます。
                     </li>
               </ul></p></li>
<li><p> コンパイラでオプション<code>--relaxed_fp</code>を使用すると、一部の浮動小数点式をより良く最適化できるようになりました。有効にした場合、コンパイラは浮動小数点式でより小さい浮動小数点型を小さくしようと試みます。これによって精度の劣化が小さくなります。
          </p></li>
  </ul>
<b>プログラム修正</b>
  <ul>
<li>
  <p>
ライブラリ関数<code>fpclassify()</code>は、正規化数と非正規化数を正しく処理できるようになりました。<br>[EW21098]
  </p>
</li>

<li>
  <p>
小さい<code>memcpy</code>の呼出しは、ソースと目的地のアドレスのアラインメントがどちらも正しい場合、代入に変換されなくなりました。<br>[EW21193]
  </p>
</li>

<li>
  <p>
コンパイラは、異なる種類の変数が同じセクションに配置されていないかをチェックするようになりました。<br>[EW21351]
  </p>
</li>

<li>
  <p>
<code>__segment_begin()</code>または<code>__segment_end()</code>が条件付きコードで使用されていても、インターナルエラーが発生しなくなりました。<br>[EW21770、EW21838、EW21905]
  </p>
</li>

<li>
  <p>
符号なしのループカウンタでゼロを通り越してループがデクリメントすると、間違って最適化されることがありました。<br>[EW21795]
  </p>
</li>

<li>
  <p>
すべてのシステムヘッダがMISRAエラーを出力しなくなりました。<br>[EW21799]
  </p>
</li>

<li>
  <p>
最適化の実行中に、コンパイラがオフセットを持つ関数ポインタを含むイニシャライザを処理するようになりました。<br>[EW21870]
  </p>
</li>

<li>
  <p>
エンディアン属性は、ポインタや配列ではサポートされていません。ポインタや配列については、エンディアン属性が指定できないようになりました。<br>[EW21887]
  </p>
</li>

<li>
  <p>
バイトオーダの逆順が、エンディアン属性およびアラインメントされていないアクセスの組合せに対しても正しく実行されるようになりました。これまでは、これが処理されないときがありました。<br>[EW21888]
  </p>
</li>

<li>
  <p>
最適化レベル[高]で、以下のような小さいループの速度を最適化した場合
    <pre><code>
int test(int n)
      {
while (n-- &gt; 0)
if (!foo(n))
break;
return n;
      }
      </code></pre>
間違って展開されて、インターナルエラーが発生することがありました。<br>[EW21949]
  </p>
</li>

<li>
  <p>
名前のない構造体であるメンバを持つクラス、または名前のない構造体の配列で、少なくともメンバの1つがPoDでない場合、コンパイル中にインターナルエラーが発生することがありました。<br>[EW21958]
  </p>
</li>

<li>
  <p>
ループテストで事前インクリメントまたは事前デクリメントを持つwhileループが、ループ本体の最終部分がdoループの場合に、間違って最適化されることがありました。<br>[EW21999]
  </p>
</li>

<li>
  <p>
コンパイラが、Thumb-2比較および分岐命令(<code>CBZ</code>または<code>CBNZ</code>)のレジスタオペランドによって、同等でない命令シーケンスを(クロスコールまたはクロスジャンプ初期化によって)マージしなくなりました。<br>[EW22000]
  </p>
</li>

<li>
  <p>
<code>enum</code>が定義される前にパラメータまたはリターン型として指定された場合、コンパイラが間違ったnumサイズ(属性<code>Tag_ABI_enum_size</code>)をELFファイルに記録しなくなりました。<br>[EW22013]
  </p>
</li>

<li>
  <p>
Thumb-2では、コンパイラが後に続く命令またはラベルの4バイトアラインメントを実現するために<code>MULS.N</code>を<code>MULS.W</code>(これはThumb-2命令ではありません)に拡げようとしても、インターナルエラーが発生しなくなりました。<br>[EW22018]
  </p>
</li>

<li>
  <p>
コンパイラが関数シンボルを、<code>memcpy</code>のようなコンパイラにより最適化された関数への引数として処理できるようになりました。<br>[EW22052]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>ネストされた<code>for</code>ループで、内部ループの初期または最終の値が外部ループの変数に定数の倍率係数や定数オフセットを掛けたものである場合、最適化レベル「高」でインターナルエラーが発生しなくなりました。<br>[EW22078]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>複数の出口を持つ一部の<code>while</code>ループで、最適化レベル「高」のときにインターナルエラーが発生しなくなりました。<br>[EW22080]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>コンパイラが直接の<code>ADR</code>参照を生成してない場合に、定数データが<code>.rodata</code>セクションに配置されるようになりました。<code>ADR</code>参照がある場合、定数データは<code>.text</code>セクションに配置されます。<br>[EW22081]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>標準C++がkickstart製品でも有効になりました。<br>[EW22089]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>MISRA-C:2004規則20.2チェッカが、長いプリプロセッサシンボル定義を処理できるようになりました。<br>[EW22117]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>Cortex-M3で、ソフトウェア割込み関数(<code>SWI</code>)への呼出しで終わる同一の命令シーケンス(クロスコール)に対して、コンパイラがサブルーチンを生成しなくなり、インターナルエラーも発生しなくなりました。<br>[EW22118]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>コンパイラが、<code>STREX</code>命令の結果を使用するコードを削除しなくなりました(この命令は、<code>__STREX</code>組込み関数を使用して生成できます)。<br>[EW22119]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>コンパイラが符号付き16ビットの値を、<code>MOVT</code>命令のイミディエイトのオペランドとして使用しなくなりました。代わりに、16ビットの符号なしの値が使用されます。この理由は、<code>MOVT</code>が0から65535のイミディエイト値を想定するためです。<br>[EW22121]
  </p>
</li>

<li>
  <p>
EWARM 6.10.2:<br>結果を使用せずに関数アドレスを評価しても、インターナルエラーが発生しなくなりました。<br>[EW22146]
  </p>
</li>
  </ul>

<h4><A NAME="his550">V5.50 2010-04-21</A></h4>
<b>新機能</b>  
  <ul>
      <li>
        <p>
VFPを持たないデバイスについて、次のCライブラリ浮動小数点関数のスピードどサイズが最適化されています。<br><code>sqrt</code>、<code>sqrtf</code>、<code>modf</code>、<code>modff</code>、<code>fabs</code>、<code>fabsf</code>、<code>fmod</code>、<code>fmodf</code>、<code>floor</code>、<code>floorf</code>、<code>ceil</code>、<code>ceilf</code>、<code>ldexp</code>、<code>ldexpf</code>、<code>frexp</code>、<code>frexpf</code>。
        </p>
      </li>
      <li>
        <p>
VFPを持つデバイスについて、次のCライブラリ浮動小数点関数のスピードどサイズが最適化されています。<br><code>sqrt</code>、<code>sqrtf</code>、<code>modf</code>、<code>modff</code>、<code>fabs</code>、<code>fabsf</code>、<code>fmod</code>、<code>fmodf</code>、<code>floor</code>、<code>floorf</code>、<code>ceil</code>、<code>ceilf</code>、<code>ldexp</code>、<code>ldexpf</code>、<code>frexp</code>、<code>frexpf</code>、<code>asin</code>、<code>asinf</code>、<code>acos</code>、<code>acosf</code>、<code>atan</code>、<code>atanf</code>、<code>atan2</code>、<code>atan2f</code>。
        </p>
      </li>
  </ul>
<b>プログラム修正</b>
  <ul>
        <li>
          <p>
関数の最後に到達するのを妨げるコードを含んだ関数を最適化する際に、最後に到達可能な命令の後にコンパイラが誤ってラベルを残していました。このラベルが後で、関数からの制御の流れの漏れと認識され、インターナルエラーが発生していました。<br>[EW21541]
          </p>
        </li>

        <li>
          <p>
ベースタイプでもキーが見つからない場合に、マップインデックス演算子の呼出しがデフォルトで値を生成するようになりました。<br>[EW21592]
          </p>
        </li>

        <li>
          <p>
C++動的初期化を必要とする静的記憶寿命オプションを持つ指定のイニシャライザ(IAR拡張が有効な場合にEC++で使用可能なC99機能)を使用する際に、誤った初期化が行われる可能性がありました。<br>[EW21649]
          </p>
        </li>

        <li>
          <p>
<code>LDC</code>および<code>STC</code>に組込みを使用した場合に、コンパイラがクラッシュすることがありました(アクセス違反)。<br>[EW21657]
          </p>
        </li>

        <li>
          <p>
関数<code>f</code>がグローバル変数を更新する際、以下の場合に誤って最適化されることがありました。<br>
            <ul>
<li><code>f</code>に複数のリターン文がある。</li>
<li>リターン文のどれか１つがループ内にあり、</li>
<li><code>f</code>が別の関数内にインライン化されている。</li>
            </ul>
[EW21666]
          </p>
        </li>

        <li>
          <p>
スタックパラメータを生成するためにコンパイラが<code>memcpy</code>への呼出しを挿入する関数呼出しの場合、レジスタ<code>R1</code>が<code>memcpy</code>の呼出し後も有効であると見なされなくなりました。<br>[EW21668]
          </p>
        </li>

        <li>
          <p>
コンパイラがアラインメントされていないCortex-M0のメモリアクセスを生成しなくなりました。<br>[EW21687]
          </p>
        </li>

        <li>
          <p>
Thumb-2対応のコアについて、サイズ指定子(<code>.W</code>または<code>.N</code>)なしにはコンパイラが分岐命令を生成しなくなりました(Thumbモードの場合)。これを行うと、場合によってインターナルエラーが発生する恐れがあるためです。<br>[EW21699]
          </p>
        </li>

        <li>
          <p>
EWARM 5.50.5:<br>列挙子の定数を直接的に浮動小数点値として使用しても、破損した値が生成されなくなりました。<br>[EW21704]
          </p>
        </li>

        <li>
          <p>
EWARM 5.50.5:<br>テンプレートパラメータに依存するサイズを持つブロックローカル静的配列の配列ポインタディケイで、インターナルエラーが発生しなくなりました。<br>例：<br>
            <pre>
template<typename C> struct Q
              {
C * get()
                {
static long x[sizeof(C)];
return (C *)x;
                }
              };</pre>
[EW21728]
          </p>
        </li>

        <li>
          <p>
EWARM 5.50.5:<br>ARM11の命令スケジューリングで、シフトオペランドを持つ<code>PKHBT</code>をスケジューリングする際に、インターナルエラーが発生しなくなりました。<br>[EW21745]
          </p>
        </li>

        <li>
          <p>
EWARM 5.50.5:<br><code>USAT</code>命令(飽和演算用)が、Thumb-2モードでも正しいビット幅により生成されるようになりました(1つずれていました)。<br>[EW21768]
          </p>
        </li>

        <li>
          <p>
EWARM 5.50.5:<br><code>double</code>から<code>long long</code>へのキャストによって、少数部分がゼロではない非常に大きな入力についても間違った値が生成されなくなりました。範囲[2^32, 2^52]の値が影響を受けていました。<br>[EW21786]
          </p>
        </li>

        <li>
          <p>
EWARM 5.50.5:<br>テストがフォーム:<br> <code>if ((condition1 &amp;&amp; condition2) ? 1 : 0)</code><br>の<code>? :</code>式である条件について、インターナルエラーが発生しなくなりました。[EW21807]
          </p>
        </li>

        <li>
          <p>
EWARM 5.50.5:<br>関数パラメータのアドレスの範囲チェックが正しく変換されるようになりました。以前はインターナルエラーが発生することがありました。<br>[EW21826]
          </p>
        </li>

        <li>
          <p>
EWARM 5.50.5:<br>コンパイラで、本体で<code>__noreturn</code>属性を持つ関数を呼び出す関数をインライン化することが可能になりました。<br>[EW21841]
          </p>
        </li>

        <li>
          <p>
In EWARM 5.50.7:<br>複数の定数テーブル参照が、(<code>LDR (immediate)</code>命令が関数の外にたどり着けないほどの)大きい関数と同じITブロックに配置された場合に、インターナルエラーが出力されなくなりました。<br>[EW21968]
          </p>
        </li>

        <li>
          <p>
In EWARM 5.50.7:<br>不変ポインタ変数を通して条件付きアクセスを含むループが、間違って最適化されなくなりました。<br>[EW21992]
          </p>
        </li>

        <li>
          <p>
In EWARM 5.50.7:<br>マイナスの除算を持つ式の符号付き除算が、最適化されて符号なしの除算を使用することがなくなりました。<br>[EW22043]
          </p>
        </li>
  </ul>

<h4><A NAME="his541">V5.41 2009-12-14</A></h4>
<b>新機能</b>    
  <ul>
    <li>
なし。
    </li>
  </ul>
<b>プログラム修正</b>
  <ul>
<li>
  <p>
<code>cstartup_M.c</code>にデフォルトの割込みハンドラが含まれています。<br>[EW21314]
  </p>
</li>

<li>
  <p>
フォーム<br> <code>if (expr &lt; 0) v = -expr;</code><br>の式が、正しく最適化されるようになりました。<br>[EW21340]
  </p>
</li>

<li>
  <p>
次の場合に、ループ内のテストが正しく最適化されるようになりました。<br> a) ループの初回および最後の繰返しの値が一定である。<br> b) テストで式が定数と比較されている。<br> c) 式の計算によって初回または最後の繰返しのどちらかがオーバフローまたはアンダーフローとなる。<br>[EW21363]
  </p>
</li>

<li>
  <p>
最適化の途中で、複雑な|-式が無限ループにならなくなりました。<br>[EW21380]
  </p>
</li>

<li>
  <p>
レジスタよりもライブの変数が多いと、レジスタがスタックフレームにあふれることがありました。あふれた大きい（8バイトを超える）レジスタパラメータによるインターナルエラーが発生しなくなりました。<br>[EW21386]
  </p>
</li>

<li>
  <p>
明示的に指定されたライブラリを使用したリンクでの属性チェックに関して、リンカがより柔軟になりました。<br>[EW21387]
  </p>
</li>

<li>
  <p>
絶対アドレスの変数アクセスによって、最適化の際に<code>volatile</code>属性が失われなくなりました。<br>[EW21400]
  </p>
</li>

<li>
  <p>
基本ベースが仮想的に継承された基底クラスから継承するクラスのデバッグ情報が、正しく生成されるようになりました。以前はこの問題によって、C-SPYで基底クラスが間違って表示されることがありました。<br>[EW21411]
  </p>
</li>

<li>
  <p>
インラインアセンブラコードのアセンブラエラーが、コンパイラのインターナルエラーとして報告されなくなりました。<br>[EW21436]
  </p>
</li>

<li>
  <p>
コンパイラで、エスケープシーケンスを使用して文字の値255が文字列リテラルにエンコードされるようになりました。これは、アセンブラがこうした値をファイル末尾として認識することを回避するためです。<br>[EW21443]
  </p>
</li>

<li>
  <p>
未使用のレジスタが名称変更の後に使用される場合に、こうしたレジスタがスタックに保存されなくなるのを防ぐため、レジスタが名称変更されなくなりました。<br>[EW21449]
  </p>
</li>

<li>
  <p>
すべての参照からアクセスできるように定数テーブルのエントリがコピーされる場合に、コンパイラがインターナルエラーを報告する代わりに、正しいコードを生成するようになりました。<br>[EW21471]
  </p>
</li>

<li>
  <p>
EWARM 5.41.2：<br>ループ内の整数式で、式が変数<code>(x + ... + C)</code>に定数を追加したり、変数から定数を差し引く場合に誤って最適化されなくなりました。また、定数ループインデックス変数<code>(x = i - C)</code>から差し引かれたもの、またはこの変数に追加されたものと同じ定数が変数に割り当てられます。<br> [EW21493]
  </p>
</li>


<li>
  <p>
EWARM 5.41.2：<br>フォーム<br> <code>expr1 &gt; c1 &amp;&amp; expr2 &lt; c2</code><br>または<br> <code>expr1 &lt; c1 || expr2 &gt; c2</code><br>に対する2つのテストは、<code>expr1</code>が<code>expr2</code>と同じでない場合に範囲テストとして誤って最適化されなくなりました。.<br>[EW21498]
  </p>
</li>


<li>
  <p>
EWARM 5.41.2：<br>定数とメモリからロードされた値間のビットごとのand処理が、ロードが切り詰められた状態に変換されることがあり、この場合は変数の一部しかメモリからロードされません。64ビットの変数の場合(つまり<code>long long</code>)、ロードが切り詰められでもインターナルエラーが発生しなくなりました。<br>[EW21517]
  </p>
</li>


<li>
  <p>
EWARM 5.41.2：<br>ループに複雑な配列インデックス式があっても、インターナルエラーが発生しなくなりました。<br>[EW21545]
  </p>
</li>


<li>
  <p>
EWARM 5.41.2：<br>32ビットより小さい型で、(たとえば<code>CMP</code>、<code>TST</code>、<code>TEQ</code>を使用して)比較する前に、符号拡張またはゼロ拡張しなければならないことがありました。ビットごとのand/xor処理の結果がゼロと比較される場合(つまり、<code>TST</code>または<code>TEQ</code>命令が生成される場合)<br>、必要があれば符号拡張およびゼロ拡張が生成されるようになりました。[EW21550]
  </p>
</li>


<li>
  <p>
EWARM 5.41.2：<br>組込み<code>__CLZ</code>、<code>__REV</code>、<code>__REVSH</code>が定数の引数とともに使用されるときに、正しい値が生成されるようになりました。<br>[EW21561]
  </p>
</li>
  </ul>

<h4><A NAME="his540">V5.40 2009-07-10</A></h4>
<b>新機能</b>  	
  <ul>
    <li>
なし。
    </li>
  </ul>
<b>プログラム修正</b>  
  <ul>

<li>
  <p>
if-then-else文が最適化レベル「低」でも疑問符の式に最適化できてしまい、どちらが最新の文なのかデバッガが混乱していました。最適化レベル「低」および」「なし」での最適化が無効にされました。<br>[EW20828]
  </p>
</li>

<li>
  <p>
オプション<code>--strict_ansi</code>および<code>--warnings_are_errors</code>が使用されていても、システムヘッダでの<code>long long</code>の使用に対して、コンパイラによりメッセージが生成されなくなりました。<br>[EW20844]
  </p>
</li>

<li>
  <p>
<code>memcpy</code>または<code>memset</code>の呼び出しに変換されたループ内の最後の値が、場合によって1つずれていることがありました。<br>[EW20886]
  </p>
</li>

<li>
  <p>
行外のテンプレートメンバ関数定義を正しい宣言に突き合せようとする際の、コンパイラのインターナルエラーを修正しました。2つ以上のテンプレートメンバ関数が、メンバ関数型のパラメータへのポインタのthis修飾子で異なる場合に、この問題が発生していました。<br>例：<br><code><pre>
struct X
      {
template<typename Y, typename Z> int fun(Y (Z::*fp)());
template<typename Y, typename Z> int fun(Y (Z::*fp)() const);
      };

template<typename Y, typename Z>
int X::fun(Y (Z::*fp)())
      {
return 1;
}</pre></code> [EW20920]
  </p>
</li>

<li>
  <p>
MISRA-Cエラー<code>Pm020</code>がワーニングとして誤って報告され、対応する規則番号がエラーメッセージから省略されていました。<br>[EW20925]
  </p>
</li>

<li>
  <p>
複数の入力ファイル(<code>--mfc</code>)をEmbedded C++モードでコンパイルする際、コンパイラで<code>[assertion failed at: &quot;.\src\parser\edg\lower_il.c&quot;, line 2484]</code>というインターナルエラーが出力される場合がありました。<br> [EW20927]
  </p>
</li>

<li>
  <p>
グローバル変数(<code>g</code>)が結果(<code>g</code>はループの繰返しの最中に値を引き渡さない)を保持するループが、誤って最適化される場合がありました。
    <pre>
for (...) {
g = ...
if (...) break;
g = ...
    }</pre>
[EW20952]
  </p>
</li>

<li>
  <p>
コンパイラおよびアセンブラがオブジェクトファイルを生成し、グループセクションヘッダテーブルのエントリが、ELFフォーマットで要求されているとおりに、すべてのメンバのエントリの前に表示されませんでした。<br>[EW20988]
  </p>
</li>

<li>
  <p>
<code>memcpy</code>の呼出しの後、バッファ(<code>b</code>)に<code>n</code>文字が長さ<code>n</code> (ゼロ終了以外のすべての文字)の文字列リテラルから割当てられ、代入<code>b[n] = 0</code>が誤って削除されていました。<br>[EW20991]
  </p>
</li>

<li>
  <p>
除算と剰余の演算を両方含む関連付きの式が、ごく稀な場合に誤って最適化されることがありました。<br>[EW21010]
  </p>
</li>

<li>
  <p>
3つ以上のクラスから継承するクラス（仮想メソッドが3つ以上の引数を持つ場合）であるThumb向けのEEC++をコンパイルする際、生成されたサンクのいずれかにエラーがありました（複数の継承がある場合にコンパイルする際、'this'ポインタを調整する小さなコードが必要なときがあります。このコードを'サンク'と呼びます)。<br> [EW21014]
  </p>
</li>

<li>
  <p>
2つのフィールド<code>a</code>および<code>b</code>によってレジスタ変数として割当てられた、8バイト以上の構造体<code>x</code>の場合、疑問符の式(<code>x.a &lt; x.b ? x.a : x.b</code>など) に短縮可能な、単純なif文がインターナルエラーの原因となることがありました。<br> [EW21017, 21108]
  </p>
</li>

<li>
  <p>
<code>memcpy</code>によって割当てられた自動構造体へのメンバアクセスが、誤って最適化される場合がありました。<br>[EW21020]
  </p>
</li>

<li>
  <p>
VFP用にコンパイルする際、変数引数リストを用いた関数呼出しで、スタック上で引き渡された引数が<code>double</code>から<code>int</code>に変換され、結果として間違ったスタックポインタ値になる可能性がありました。<br>[EW21023]
  </p>
</li>

<li>
  <p>
Thumbモードの<code>--legacy RVCT3.0</code>を用いてコンパイルする場合に、同じコンパイルユニットの関数同士で定数が共有され、2バイトのアラインメントを持つ1つのセグメントパート内に関数のいずれかが生成されることがありました。こうした場合に<code>R_ARM_THM_PC8</code>の再配置を正しく解決するには、4バイトのアラインメントが必要です。<br>[EW21031]
  </p>
</li>

<li>
  <p>
コードジェネレータが、タイプで要求されたものよりも厳密なアラインメントを用いて配置されたオブジェクトを検出できないことがありました。これによって、後の段階でコードジェネレータが上位のアラインメントを必要とした場合に、コンパイラがクラッシュする可能性がありました。<br>[EW21059]
  </p>
</li>

<li>
  <p>
ループ内の切替え文がマイナスのオフセットを持つテーブルとして生成される場合、テーブルルックアップで同じレジスタが2つの異なる目的で再利用できました。<br>[EW21100]
  </p>
</li>

<li>
  <p>
テンプレートクラス内で定義されたenum型がある場合に、コンパイラがインターナルエラーにより終了することがありました。<br>[EW21101, 21112]
  </p>
</li>

<li>
  <p>
ループを最適化するときに、ループの制限が、ビット単位のAND演算におけるマイナスの値が関係する式の結果である場合、ループ本体が少なくとも1回は実行され、制限に対する初期イテレータ値のテストを削除するものとして、コンパイラが間違った結論を出す恐れがありました。ループ本体がまったく実行されるべきでない場合でも、結果として間違ったループコードになっていました。<br>[EW21118,21120]
  </p>
</li>

<li>
  <p>
EWARM 5.40.4：<br>ランタイムライブラリが、Cortex-M0またはCortex-M1でアラインメントされていないアクセスがサポートされていると想定しないようになりました。<br>[EW21262]
  </p>
</li>
<li>
  <p>
EWARM 5.40.4：<br>32ビットより小さいスカラスタックパラメータは、関数が呼び出される前に正しく符号またはゼロで拡張されるようになりました。<br>[EW21271]
  </p>
</li>
<li>
  <p>
EWARM 5.40.4：<br>組込み<code>__get_interrupt_state</code>または<code>__set_interrupt_state</code>のどちらかを使用したファイルのコンパイルで、インターナルエラーが発生しなくなりました。<br>[EW21272]
  </p>
</li>
<li>
  <p>
EWARM 5.40.4：<br>MISRA-CがEWARM-CMで使用できるようになりました。<br>[EW21324]
  </p>
</li>
<li>
  <p>
EWARM 5.40.4：<br>コンパイラで、別のモジュールで定義されたC++メンバ関数の呼出しに対して、正しいデバッグ情報が生成されるようになりました。こうした呼出し用の<b>step into</b>デバッガコマンドが現在は正常に機能します。<br>[EW21327]
  </p>
</li>
  </ul>

<h4><A NAME="his530">V5.30 2009-01-23</A></h4>
<b>新機能</b>  	
    <ul>
<li><b>__task拡張キーワード</b><br> デフォルトでは、関数は使用された保護レジスタの内容を入口でスタックに保存し、出口で復元します。<code>_task</code>を使用して宣言された関数の場合、レジスタを保存しないため、必要なスタックエリアが小さくなります。これは通常、リアルタイムOSで使用されます。
      </li>
	</ul>
<b>プログラム修正</b>
	<ul>

      <li>
        <p>
フィールドのどれかにタイプエラーがある状態でタイプがクラス/構造体/共用体の変数を作成すると、インターナルエラーを引き起こすことがありました。これは修正されました。<br>[EW20367]
        </p>
      </li>

      <li>
        <p>
ごく稀な場合に、コンパイラが異常終了することがありました。異常終了が回避されるようになりました。<br>[EW20380]
        </p>
      </li>

      <li>
        <p>
リストファイルで報告されるスタックの使用は、再び安全な近似値になりました。<br>[EW20410]
        </p>
      </li>

      <li>
        <p>
連続する2つの式の前後のインクリメント/ディクリメントによって、インターナルエラーが起きることがありました。この問題は修正されました。<br>[EW20419]
        </p>
      </li>

      <li>
        <p>
ごく稀に、不規則なループが間違って最適化される場合がありました。この問題は修正されました。<br>[EW20428]
        </p>
      </li>

      <li>
        <p>
複数レベルの匿名共用体/構造体の内部にあるフィールド上で指示されたイニシャライザを指定すると、コンパイラでインターナルエラーとなることがありました。この問題は修正されました。<br>[EW20439]
        </p>
      </li>

      <li>
        <p>
インラインアセンブラの操作によって、ELFで絶対アドレッシングに対してエラーが正しく生成されるようになりました。<br>[EW20489]
        </p>
      </li>

      <li>
        <p>
特定のループコンストラクトにコードを生成するときに、コンパイラが失敗することがありました。これは修正されました。<br>[EW20503]
        </p>
      </li>

      <li>
        <p>
ネストされた2つのループ内にあるアドレス式が、値を割当てられる前に変数を使用できる場合がありました。これは修正されました。<br>[EW20531]
        </p>
      </li>

      <li>
        <p>
Cortex-M3の最適化レベル「中」（またはそれ以上）の場合、定数256と疑問符演算子(<code>a?b:c</code>)の特定の組合せをコンパイルすると、&quot;illegal state&quot;（無効なステート）というメッセージが出力されてインターナルエラーとなることがありました。これは修正されました。<br>[EW20537]
        </p>
      </li>

      <li>
        <p>
小さい型(<code>char</code>など)の変数が、ラップされる可能性がありながらも、ループカウンタとして間違って巻き上げられることがありました。これは修正されました。<br>[EW20563]
        </p>
      </li>

      <li>
        <p>
連続するshort、integer、long longをコピーする<code> do </code>ループが、memcpy呼出しに変換されたときに、正しいバイトカウントを持つようになりました。<br>[EW20570]
        </p>
      </li>

      <li>
        <p>
リターン値ポインタを使用する関数に作成されたリターン値の一時値が、アドレスを取得済みとしてマークされませんでした。これは修正されました。<br>[EW20572]
        </p>
      </li>

      <li>
        <p>
同じメモリアドレスにアクセスするために異なるタイプのポインタが使用されていると、コードが誤って最適化される場合がありました。これは修正されました。<br>[EW20581]
        </p>
      </li>

      <li>
        <p>
整数型のテンプレート静的データメンバが関係する特定の操作(通常はビットの操作)によって、テンプレートコードのコンパイル時にインターナルエラーが発生する場合がありました。これは修正されました。<br>[EW20608]
        </p>
      </li>

      <li>
        <p>
グローバル変数と同じタイプの間接的なストアの後に続くグローバル変数をループが更新するときに、間違って最適化される場合がありました。<br>[EW20627]
        </p>
      </li>

      <li>
        <p>
コンパイラがIT-ブロックに<code>CPSIE/CPSID</code>を入れようとしなくなりました。<br>[EW20652]
        </p>
      </li>

      <li>
        <p>
最小および最大のテンプレートが、関数インライン化の後に正しく最適化されるようになりました。<br>[EW20654]
        </p>

      <li>
        <p>
コンパイラが、エラーPe020を出力した後にクラッシュしなくなりました。<br>[EW20684]
        </p>

      <li>
        <p>
組込み関数__set_CPSR() が、間違ったアセンブラ命令を生成していました。これは修正されました。<br>[EWARM-268]
        </p>

      </li>

    </ul>

<h4><A NAME="his520">V5.20 2008-06-24</A></h4>
<b>新機能</b>  
    <ul>
      <li>
        <p>
	  ベクタ浮動小数点(VFP)コプロセッサのサポート。
	</p>
      </li>
	  </ul>
<b>プログラム修正</b>
	  <ul>
      <li>
        <p>
コンパイラが、初期化されていない揮発性の自動変数からのリードを、コードから削除しなくなりました。<br>[EW19167]
        </p>
      </li>
      <li>
        <p>
フォールスルーを持つサンクが、必要なときにいつでも正しくパッドされるようになりました。<br>[EW19481]
        </p>
      </li>
      <li>
        <p>
<code> #line </code>ディレクティブの後のソース行が、コンパイラのリストファイルにインクルードされるようになりました。<br>[EW19654]
        </p>
      </li>
      <li>
        <p>
コンパイラが、アセンブラ命令やレジスタ名などと同じセグメント/セクション名を処理できるようになりました。<br>[EW19674]
        </p>
      </li>
      <li>
        <p>
テンプレートクラスのメンバ関数の行外の定義が、正しく仮になるようになりました。<br>[EW19678]
        </p>
      </li>
      <li>
        <p>
クラス固有の2つのオペランドを持つ演算子、<code> delete </code>をクラステンプレートで宣言しても、コンパイラがクラッシュしなくなりました。<br>[EW19707]
        </p>
      </li>
      <li>
        <p>
外部の<code> typename </code>キーワードがテンプレートにあるというエラーを出力した後に、コンパイラがクラッシュしなくなりました。<br>[EW19796]
        </p>
      </li>
      <li>
        <p>
MISRA-C規則23で、コード以外のシンボルにエラーが出力されなくなりました。<br>[EW19802]
        </p>
      </li>
      <li>
        <p>
Reallocが、ヒープにある以上のメモリを割り当てようとする呼出しの後で、ヒープを破損したステートのままにしなくなりました。<br>[EW19803]
        </p>
      </li>
      <li>
        <p>
10以上の定数を持つクラスによってスコープされた<code> enum </code>型のクラス外部<code> typedef </code>にDWARFデバッグ情報を生成するときに、コンパイラがクラッシュすることがなくなりました。<br>[EW19820]
        </p>
      </li>
      <li>
        <p>
Cortex-M3で<code> memcpy </code>を実行していて、ソースと対象へのポインタのアラインメントが異なる場合、サイズが以下のときに最後の16バイトがコピーされるようになりました。<br><code>size = 32 + ((4 -(DstPtr &amp; 3)) &amp; 3) + (y * 16);       // y = 0、1、2など<br></code> [EW19837]
        </p>
      </li>
      <li>
        <p>
命令スケジューリングが、関数/ライブラリの呼出しよりもLRのポップを優先しなくなりました。<br>[EW19872]
        </p>
      </li>
      <li>
        <p>
アラインメントされたパラメータを持つ<code> memmove </code>への呼出しが、<code> __aeabi_memmove4</code>ではなく、誤って<code> __aeabi_memcpy4 </code>に変換されることがなくなりました。<br>[EW19878]
        </p>
      </li>
      <li>
        <p>
<code> long long </code>値のマスクが機能するようになりました。<br>[EW19908]
        </p>
      </li>
      <li>
        <p>
関数の呼出し（あるパラメータが、同じサイズの符号なしの型へのポインタのキャストである符号付き整数型へのポインタであるか、またはその逆の場合）、関数の呼出しがインライン化されるときにインターナルエラーが起こらなくなりました。<br>[EW19933]
        </p>
      </li>
      <li>
        <p>
0から1へと変わる符号なしのループ変数を持つループが、間違って最適化されなくなりました。<br>[EW19973]
        </p>
      </li>
      <li>
        <p>
Thumb2コードの定数テーブルのレイアウト生成が調整されました。<br>[EW19984]
        </p>
      </li>
      <li>
        <p>
ソースが増分された前または後のポインタの間接であるときに、構造体の割当てが間違って最適化される場合が稀にありました。これは修正されました。<br>[EW20071]
        </p>
      </li>
      <li>
        <p>
Thumb2コード内の大きなレジスタ(<code>r8-r14</code>)の変数のデバッグ情報が改善されました。<br>[EW20098]<br> [EW20100]
        </p>
      </li>
      <li>
        <p>
クラスタ化で、セグメント/セクションにより配置された初期化済みの変数が処理できるようになりました。<br>[EW20149]
        </p>
      </li>
      <li>
        <p>
ごく稀に、レジスタへのメモリセル(グローバル変数や構造体メンバなど)を一時的に巻き上げる最適化によって、コードが正しく変換されず、1つまたは複数の使用がそのメモリセルを参照したままになることがありました。これは修正されました。<br>[EW20150]
        </p>
      </li>
      <li>
        <p>
ARM関数からthumb関数へのフォールスルーが、生成されなくなりました。<br>[EW20164]
        </p>
      </li>
      <li>
        <p>
無効な命令でインターナルエラーが生成されなくなりました。<br>[EW20199]
        </p>
      </li>
      <li>
        <p>
<code>Tag_ABI_enum_size </code>が、使用される<code> enum </code>の実際のサイズを反映するようになりました。<br>[EW20203]
        </p>
      </li>
    </ul>

<h4><A NAME="his511">V5.11 2007-12-11</A></h4>
<b>新機能</b>  
    <ul>
      <li>
	  Cortex-M1およびCortex-M3のサポート。
      </li>
     </ul>
<b>プログラム修正</b>
	 <ul>
      <li>
        <p>
コードジェネレータが集合タイプの小さなオブジェクトをレジスタ内に配置できなかった場合、代わりにオブジェクトをスタック上に配置しようとしても失敗することがありました。オブジェクトのアラインメントが集合メンバのサイズと一致せず、アラインメント境界上に配置されたものを除くすべてのメンバに間違ったオフセットが使用されるときに、この問題が発生していました。<br>[EW19478]
        </p>
      </li>
      <li>
        <p>
最上位ビットを除くすべてに対する32ビットのマスク処理と、同じ変数の最上位ビットへのテストが、Thumbモードで間違ったコードを生成する場合がありました。<br>[EW19480]
        </p>
      </li>
      <li>
        <p>
セクション&quot;.textrw&quot; の名前を変更できるようになりました。<br>[EW19672]
        </p>
      </li>
      <li>
        <p>
コンパイラで、アセンブラ命令、レジスタなどと同じ名前を持つセグメント/セクションを処理できるようになりました。<br>[EW19674]
        </p>
      </li>
      <li>
        <p>
テンプレートクラスのメンバ関数の行外の定義が、正しく仮のものにならず、リンクの際に誤って'重複する定義'となっていました。これは修正されました。<br>[EW19678]
        </p>
      </li>
      <li>
        <p>
クラス固有の2つのオペランドを持つ演算子、 deleteをクラステンプレートで宣言しても、コンパイラがクラッシュしなくなりました。<br>[EW19707]
        </p>
      </li>
      <li>
        <p>
関数の宣言の不正な構文によって、インターナルエラーが生成されなくなりました。<br>[EW19718]
        </p>
      </li>
      <li>
        <p>
Doubleが正しく丸められるようになりました。<br>[EW20026]
        </p>
      </li>
    </ul>

<h4><A NAME="his510">V5.10 2007-06-12</A></h4>
<b>新機能</b>  
    <ul>
      <li>
オブジェクトファイルがELF/DWARFフォーマットで生成されるようになりました。
      <li>
	      AEABIのサポート（ARM EABIに準拠する他のツールとの相互運用性）
      </li>
	 </ul>
<b>プログラム修正</b>
	 <ul>
      <li>
	  静的変数のイニシャライザにビットフィールドメンバのアドレスが含まれる場合に、コンパイラがエラーを出力するようになりました。<br>[EW17962]
      <li>
	  関数に類似したマクロで、事前定義されたIAR属性名として名前が付けられていても、コンパイラが異常終了しなくなりました。<br>[EW18386]
      <li>
	  ごく稀な場合に、64ビット変数の上位部分だけがロードされました。<br>[EW18735] 
      <li>
	  組込み関数<code>__no_operation()</code>を使用して挿入されたNOP命令が、コード内の希望する位置に表示されないままスケジュールされていました。<br>[EW18767] 
      <li>
ヘッダファイル<code>MtxWrapper.h</code>がC++から動作するようになりました。<br>[EW18769]
      <li>
	  <code> char </code>型のインデックス式を持つ配列アクセスを含むループが、間違って最適化される場合がありました。<br>[EW18815,EW18963]
      <li>
	  宣言同士の不一致、または同じ関数の宣言と定義の不一致について、正しい診断結果が出るようになりました。<br>[EW18818]
      <li>
	  ヘッダファイル<code>Dlib_Product.h</code>がMISRA-Cと互換になりました。<br>[EW18843]
      <li>
	  ゼロおよび同じ構造体からのリードを持つ、織り交ざったストアが、以前は間違った順序で行われていました。<br>[EW18845]
      <li>
	      アラインメントされていない構造体をビッグエンディアンモードでパラメータとして引き渡す際に、間違ったコードが生成されました。<br>[EW18900]
      <li>
	      <code>swprintf</code>と<code>vswprintf</code>で、末尾の<code>\0</code>が正しく処理されるようになりました。<br>[EW18948]
      <li>
	      ごく稀な場合に、同じ構造体の他のメンバと定数 (<code>p-&gt;y == 0</code>)間の等式テストが式の前にあると、構造体ポインタ(<code>p-&gt;x</code>)を含む共通部分式が、間違って最適化されていました。<br>[EW19015]
      <li>
<code>__irq</code>と<code>__fiq</code>を持つ関数が、vfpについてコンパイルする際に、vfpステータスレジスタを保存するようになりました。<br>[EW19047]
      <li>
コンパイラが、ファイルでスコープ化された初期化で使用される複合リテラルに間違った定数を生成しなくなりました。<br>[EW19076]
      <li>
<code>swprintf</code>が大きな文字列を正しく処理するようになりました。<br>[EW19105]
      <li>
大きな関数が以下のインターナルエラーを出力する場合がありました：<code>Internal Error:[CoreUtil/General]:Jump distance to far for B</code>.<br>[EW19179]
      <li>
クラスタ化によって、ゼロに初期化されたデータが、ゼロ初期化を使用するのでなく、ROM空間を占有する場合がありました。<br>[EW19232]
      <li>
<code>char</code>バッファのバイト上の<code> ! </code>演算子(例:<code>return !buf[0];</code>) でインターナルエラーが起きる可能性がありました:<br><code>Const_Folding - Internal error Unequal types for operator != <br> Internal Error:[CoreUtil/General]:Const_Folding - Internal error</code><br> [EW19337]
    </ul>
    </div>
</body>
</html>
